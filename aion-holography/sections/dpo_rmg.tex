\sectionbreak
\section{DPO Rewriting on Recursive Metagraphs}
\label{sec:dpo-rmg}

We recall double--pushout with interfaces (DPOI) rewriting on typed open
graphs and lift it to RMG states.

\subsection{Typed open graphs and DPOI rules}

Let $T$ be a finite set of types.
Let $\OGraph_T$ be the category of $T$-typed open graphs, whose objects
are cospans of monos $I \mono G \mono O$ and whose morphisms are
commuting maps of cospans.  This category is adhesive; in particular,
pushouts along monos exist and form Van Kampen squares.

\begin{definition}[DPOI rule]
A \emph{DPOI rule} is a span of monos in $\OGraph_T$
\[
  p = (L \xleftarrow{\ell} K \xrightarrow{r} R)
\]
with $L$ the left-hand side, $K$ the interface, and $R$ the right-hand
side.  A \emph{match} of $p$ in a host graph $G$ is a mono
$m : L \mono G$ satisfying the usual gluing conditions: the
dangling condition and the identification condition.
\end{definition}

Given a match, the DPO construction yields a rewrite step
$G \Rewrite_p H$ by computing a pushout complement and a pushout:

\[
\begin{tikzcd}
  K \arrow[r,"\ell"] \arrow[d,"k"'] &
  L \arrow[d,"m"] \\
  D \arrow[r] & G
\end{tikzcd}
\qquad
\begin{tikzcd}
  K \arrow[r,"r"] \arrow[d,"k"'] &
  R \arrow[d] \\
  D \arrow[r] & H
\end{tikzcd}
\]

All arrows are monos in $\OGraph_T$.

\subsection{RMG states as two-plane objects}

An RMG \emph{state} will be written
\[
  \mathcal{U} = (G; \alpha,\beta)
\]
where $G \in \OGraph_T$ is the skeleton and $\alpha,\beta$ assign
attachment objects in the appropriate fibers to nodes and edges of $G$.
Rewriting operates in two ``planes'':

\begin{itemize}[leftmargin=*]
  \item \emph{attachment steps} are DPOI steps in the fibers
    $\alpha(v)$, $\beta(e)$ that do not change $G$;
  \item \emph{skeleton steps} are DPOI steps on $G$ itself, subject to
    rules ensuring that attachments at preserved positions can be
    transported.
\end{itemize}

A \emph{tick} consists of a finite family of attachment steps followed
by a finite family of skeleton steps, chosen by the scheduler and
satisfying independence and a no-delete-under-descent invariant.

We now turn to the determinism properties of this semantics.